<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="c&#x2F;c++基础const的用法 首先说说const的用法（绝对不能说是常数）  1）在定义的时候必须进行初始化2）指针可以是const  指针，也可以是指向const对象的指针3）定义为const的形参，即在函数内部是不能被修改的4）类的成员函数可以被声明为常成员函数，不能修改类的成员变量5）类的成员函数可以返回的是常对象，即被const声明的对象6）类的成员变量是常成员变量不能在声明时初始化，必">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2019/11/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="c&#x2F;c++基础const的用法 首先说说const的用法（绝对不能说是常数）  1）在定义的时候必须进行初始化2）指针可以是const  指针，也可以是指向const对象的指针3）定义为const的形参，即在函数内部是不能被修改的4）类的成员函数可以被声明为常成员函数，不能修改类的成员变量5）类的成员函数可以返回的是常对象，即被const声明的对象6）类的成员变量是常成员变量不能在声明时初始化，必">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic2.zhimg.com/v2-1c5da3391ad30aa7aa30f9362407a77f_b.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-dc0bdc69237df055ff8c2aa477887237_1440w.jpg">
<meta property="article:published_time" content="2019-11-19T08:13:43.696Z">
<meta property="article:modified_time" content="2020-11-02T13:22:25.865Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/v2-1c5da3391ad30aa7aa30f9362407a77f_b.jpg">


<link rel="canonical" href="http://example.com/2019/11/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title> | Hexo</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c-c-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">c&#x2F;c++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">const的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%AA%E8%AF%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">const如何做到只读?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">static的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%EF%BC%8Cnew-delete%E5%92%8Cmalloc-free%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">C++中，new&#x2F;delete和malloc&#x2F;free的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof%E5%92%8Cstrlen%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.</span> <span class="nav-text">sizeof和strlen的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">指针和引用的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%A4%9A%E6%80%81%E6%80%A7%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">C++多态性、虚函数、虚函数表、纯虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84-ifndef-define-endif-%E5%B9%B2%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">头文件中的 ifndef&#x2F;define&#x2F;endif 干什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extern-c"><span class="nav-number">1.8.</span> <span class="nav-text">extern c</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-11"><span class="nav-number">2.</span> <span class="nav-text">c++11</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E3%80%81unordered-map"><span class="nav-number">2.1.</span> <span class="nav-text">map、unordered_map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">2.2.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">右值引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PYTHON%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">PYTHON基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#python%E4%B8%8Ec%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.1.</span> <span class="nav-text">python与c的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python-%E7%9A%84GIL%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.0.2.</span> <span class="nav-text">python 的GIL、多线程、多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-deepcopy"><span class="nav-number">3.0.3.</span> <span class="nav-text">深拷贝 deepcopy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python2%E5%92%8Cpython3%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.0.4.</span> <span class="nav-text">python2和python3区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang"><span class="nav-number">4.</span> <span class="nav-text">Golang</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text">进程、线程、协程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">协程的底层实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#golang%E4%B8%AD%E7%9A%84channel"><span class="nav-number">4.3.</span> <span class="nav-text">golang中的channel</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">5.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text">HashMap 的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.2.</span> <span class="nav-text">深拷贝和浅拷贝区别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">5.3.</span> <span class="nav-text">spring 事务实现方式有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB"><span class="nav-number">5.4.</span> <span class="nav-text">spring 的事务隔离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.5.</span> <span class="nav-text">sleep() 和 wait() 有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">5.6.</span> <span class="nav-text">线程的 run()和 start()有什么区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3"><span class="nav-number">6.</span> <span class="nav-text">数据结构与算法相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">6.1.</span> <span class="nav-text">数组和链表的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88%E9%95%BF%E5%BA%A6%E6%9C%AA%E7%9F%A5%EF%BC%89%EF%BC%8C%E8%AF%B7%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%97%A2%E8%8A%82%E7%9C%81%E6%97%B6%E9%97%B4%E5%8F%88%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%97%E6%B3%95%E6%9D%A5%E6%89%BE%E5%87%BA%E8%AF%A5%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACm%E4%B8%AA%E5%85%83%E7%B4%A0%E3%80%82"><span class="nav-number">6.2.</span> <span class="nav-text">给定一个单向链表（长度未知），请设计一个既节省时间又节省空间的算法来找出该链表中的倒数第m个元素。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100w%E4%B8%AA%E6%95%B0%EF%BC%8C%E6%89%BE%E5%85%B6%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84100%E4%B8%AA%EF%BC%88%E7%94%A8%E5%BF%AB%E6%8E%92%EF%BC%89"><span class="nav-number">6.3.</span> <span class="nav-text">100w个数，找其中最大的100个（用快排）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%89%BE%E5%85%B6%E4%B8%AD%E4%B8%A4%E4%B8%A4%E7%9B%B8%E5%8A%A0%E5%92%8C%E4%B8%BAM%E7%9A%84%E5%A4%9A%E7%BB%84%E6%95%B0%E6%8D%AE%EF%BC%88%E7%94%A8m%E5%87%8F%E5%8E%BB%E6%89%80%E6%9C%89%E7%9A%84%E5%80%BC%E6%94%BE%E5%85%A5hash%E8%A1%A8%E4%B8%AD%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">一组数据，找其中两两相加和为M的多组数据（用m减去所有的值放入hash表中）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0"><span class="nav-number">6.5.</span> <span class="nav-text">给定字符串，转换为整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="nav-number">6.6.</span> <span class="nav-text">链表反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.7.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">6.8.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">7.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">tcp三次握手的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">7.2.</span> <span class="nav-text">TCP四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-amp-UDP"><span class="nav-number">7.3.</span> <span class="nav-text">TCP&amp;UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-URL-%E5%9C%B0%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">7.4.</span> <span class="nav-text">在浏览器中输入 URL 地址到显示主页的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-amp-https"><span class="nav-number">7.5.</span> <span class="nav-text">http &amp; https</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E7%B1%BB%E7%9B%B8%E5%85%B3"><span class="nav-number">8.</span> <span class="nav-text">工程类相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.1.</span> <span class="nav-text">多线程和多进程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.2.</span> <span class="nav-text">动态链接和静态链接的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.3.</span> <span class="nav-text">网络IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E7%94%A8%E8%BF%87Linux%E4%B8%AD%E7%9A%84epoll%E5%90%97%EF%BC%9F%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">8.4.</span> <span class="nav-text">有用过Linux中的epoll吗？它的作用是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis"><span class="nav-number">8.5.</span> <span class="nav-text">redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx"><span class="nav-number">8.6.</span> <span class="nav-text">Nginx</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git"><span class="nav-number">8.7.</span> <span class="nav-text">Git</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka"><span class="nav-number">8.8.</span> <span class="nav-text">kafka</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql"><span class="nav-number">8.9.</span> <span class="nav-text">mysql</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="nav-number">8.10.</span> <span class="nav-text">c++进程内存空间分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">8.11.</span> <span class="nav-text">什么是死锁?如何避免死锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%BB%B4"><span class="nav-number">9.</span> <span class="nav-text">运维</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/11/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-11-19 16:13:43" itemprop="dateCreated datePublished" datetime="2019-11-19T16:13:43+08:00">2019-11-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-02 21:22:25" itemprop="dateModified" datetime="2020-11-02T21:22:25+08:00">2020-11-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="c-c-基础"><a href="#c-c-基础" class="headerlink" title="c/c++基础"></a>c/c++基础</h1><h2 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h2><ol>
<li>首先说说const的用法（绝对不能说是常数）</li>
</ol>
<p>1）在定义的时候必须进行初始化<br>2）指针可以是const  指针，也可以是指向const对象的指针<br>3）定义为const的形参，即在函数内部是不能被修改的<br>4）类的成员函数可以被声明为常成员函数，不能修改类的成员变量<br>5）类的成员函数可以返回的是常对象，即被const声明的对象<br>6）类的成员变量是常成员变量不能在声明时初始化，必须在构造函数的列表里进行初始化<br>（注：千万不要说const是个常数，会被认为是外行人的！！！！哪怕说个只读也行）<br>下面的声明都是什么意思？<br>const int a; a是一个常整型数<br>int const a; a是一个常整型数<br>const int *a; a是一个指向常整型数的指针，整型数是不可修改的，但指针可以<br>int * const a; a为指向整型数的常指针，指针指向的整型数可以修改，但指针是不可修改的<br>int const * a const; a是一个指向常整型数的常指针，指针指向的整型数是不可修改的，同时指针也是不可修改的<br>通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>
<ol start="2">
<li>const在类中修饰函数</li>
</ol>
<p>在类中将成员函数修饰为const表明在该函数体内，<strong>不能修改对象的数据成员而且不能调用非const函数</strong>。为什么不能调用非const函数？因为非const函数可能修改数据成员，const成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数。</p>
<p>int get() const{ return i;}</p>
<p>const修饰函数返回值</p>
<p>（返回const只对左值有意义，即返回引用或者指针的时候。目的是防止返回的对象被任意修改）</p>
<p> 1.以“指针传递”方式的函数返回值加上const修饰，那么该函数的返回值的内容不能被修改</p>
<p> 例如：const char *get_string(void)</p>
<p> 2.如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部的临时存储单元中，所以加上const修饰没有意义</p>
<p>例如：int get_number(void)不用写成const int get_number(void)</p>
<p>返回值不是内部数据类型，例如：A get_string(void),这样会产生一个临时的对象用来存放返回的数据，<br>         会调用拷贝构造函数，这样效率会低，所以采用“引用传递”A &amp;get_string(void),如果加上const那么返回值的<br>         内容就不会被改变const A &amp;get_string(void)</p>
<p>用引用作函数的返回值的<strong>最大的好处是在内存中不产生返回值的副本</strong></p>
<p>函数返回引用：实际上是一个变量的内存地址，既然是内存地址的话，那么肯定可以读写该地址所对应的内存区域的值，即就是“左值”，可以出现在赋值语句的左边。</p>
<p>（1）使用引用当作函数参数和返回值，效率更高。<br>（2）函数返回的对象引用，必须在调用函数前就已经存在，不允许返回局部变量的引用！<br>（3）当不希望返回的对象被修改的时候，可以添加const。</p>
<p>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。</p>
<h3 id="const如何做到只读"><a href="#const如何做到只读" class="headerlink" title="const如何做到只读?"></a>const如何做到只读?</h3><p>这些在编译期间完成，对于内置类型，如int， 编译器可能使用常数直接替换掉对此变量的引用。而对于结构体不一定。</p>
<h2 id="static的用法"><a href="#static的用法" class="headerlink" title="static的用法"></a>static的用法</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html">https://www.cnblogs.com/BeyondAnyTime/archive/2012/06/08/2542315.html</a></p>
<p>static关键字主要起隐藏作用</p>
<p>1.面向过程设计中的static</p>
<p>1.1、静态全局变量</p>
<p>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">//定义静态全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　n=<span class="number">20</span>;</span><br><span class="line"> 　<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> 　fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态全局变量有以下特点：</strong><br>• 该变量在全局数据区分配内存；<br>• 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；<br>• 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；　</p>
<p>1.2 静态局部变量</p>
<p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 3</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　fn();</span><br><span class="line"> 　fn();</span><br><span class="line"> 　fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　<span class="keyword">static</span> n=<span class="number">10</span>;</span><br><span class="line"> 　<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">　　 n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。<br>静态局部变量有以下特点：<br>• 该变量在全局数据区分配内存；<br>• 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；<br>• 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；<br>• 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</p>
<p>1.3、静态函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example 4</span></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span></span>;<span class="comment">//声明静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span><span class="comment">//定义静态函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 　<span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line"> 　<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义静态函数的好处：<br>• 静态函数不能被其它文件所用；<br>• 其它文件中可以定义相同名字的函数，不会发生冲突；</p>
<p>2、面向对象的static关键字（类中的static关键字）</p>
<p>2.1 静态数据成员</p>
<p>• 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；<br>• 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。<br>• 静态数据成员和普通数据成员一样遵从public,protected,private访问规则；<br>• 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；<br>• 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：<br>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞<br>• 类的静态数据成员有两种访问形式：<br>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞<br>• 同全局变量相比，使用静态数据成员有两个优势：<br>\1. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；<br>\2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；</p>
<p>2.2 静态成员函数</p>
<p>• 出现在类体外的函数定义不能指定关键字static；<br>• 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数；<br>• 非静态成员函数可以任意地访问静态成员函数和静态数据成员；<br>• 静态成员函数不能访问非静态成员函数和非静态数据成员；<br>• 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；<br>• 调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：<br>＜类名＞::＜静态成员函数名＞（＜参数表＞）<br>调用类的静态成员函数。</p>
<p>1）在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2）在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>3）在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用<br>4）类内的static成员变量属于整个类所拥有，不能在类内进行定义，只能在类的作用域内进行定义<br>5）类内的static成员函数属于整个类所拥有，不能包含this指针，只能调用static成员函数<br>static全局变量与普通的全局变量有什么区别?static局部变量和普通局部变量有什么区别?static函数与普通函数有什么区别?<br>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;<br>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；<br>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p>
<h2 id="C-中，new-delete和malloc-free的区别"><a href="#C-中，new-delete和malloc-free的区别" class="headerlink" title="C++中，new/delete和malloc/free的区别"></a>C++中，new/delete和malloc/free的区别</h2><p>1、new/delete是C++的操作符，而malloc/free是C中的函数。<br>2、new做两件事，一是分配内存，二是调用类的构造函数；同样，delete会调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。<br>3、new建立的是一个对象，而malloc分配的是一块内存；new建立的对象可以用成员函数访问，不要直接访问它的地址空间；malloc分配的是一块内存区域，用指针访问，可以在里面移动指针；new出来的指针是带有类型信息的，而malloc返回的是void指针。<br>4、new/delete是保留字，不需要头文件支持；malloc/free需要头文件库函数支持。</p>
<h2 id="sizeof和strlen的区别"><a href="#sizeof和strlen的区别" class="headerlink" title="sizeof和strlen的区别"></a>sizeof和strlen的区别</h2><p>1、sizeof 操作符的结果类型是 size_t，它在头文件中 typedef 为 unsigned int 类型。该类型保证能容纳实现所建立的最大对象的字节大小。<br>2、sizeof 是运算符，strlen 是函数。<br>3、sizeof 可以用类型做参数，strlen 只能用 char* 做参数，且必须是以 \0 结尾的。<br>4、数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。<br>5、大部分编译程序在编译的时候就把 sizeof 计算过了，是类型或是变量的长度，这就是 sizeof(x) 可以用来定义数组维数的原因。<br>6、strlen 的结果要在运行的时候才能计算出来，是用来计算字符串的长度，不是类型占内存的大小。<br>7、sizeof 后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为 sizeof 是个操作符不是个函数。<br>8、当适用一个结构类型或变量时， sizeof 返回实际的大小；当适用一静态地空间数组， sizeof 归还全部数组的尺寸；sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸。</p>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>1）引用是直接访问，指针是间接访问。<br>2）引用是变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间<br>3）引用绑定内存空间（必须赋初值），是一个变量别名不能更改绑定，可以改变对象的值。<br>总的来说：引用既具有指针的效率，又具有变量使用的方便性和直观性</p>
<h2 id="C-多态性、虚函数、虚函数表、纯虚函数"><a href="#C-多态性、虚函数、虚函数表、纯虚函数" class="headerlink" title="C++多态性、虚函数、虚函数表、纯虚函数"></a>C++多态性、虚函数、虚函数表、纯虚函数</h2><p>C++<em>中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，</em>RTTI<em>技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</em></p>
<p>虚函数表：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016868575">https://segmentfault.com/a/1190000016868575</a></p>
<p>纯虚函数：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Hackbuteer1/article/details/7558868">https://blog.csdn.net/Hackbuteer1/article/details/7558868</a></p>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”<br>　virtual void funtion1()=0</p>
<p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p>
<p>重载与重写/覆盖</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_35512245/article/details/54773552">https://blog.csdn.net/sinat_35512245/article/details/54773552</a></p>
<p>1.重载：重载从overload翻译过来，是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p>
<p>2.重写：重写翻译自override，也翻译成覆盖（更好一点），是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p>
<p>重载和重写的区别：<br>（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。<br>（2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。<br>（3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。</p>
<h2 id="头文件中的-ifndef-define-endif-干什么用？"><a href="#头文件中的-ifndef-define-endif-干什么用？" class="headerlink" title="头文件中的 ifndef/define/endif 干什么用？"></a>头文件中的 ifndef/define/endif 干什么用？</h2><p>预处理，防止头文件被重复使用，包括pragma once都是这样的</p>
<h2 id="extern-c"><a href="#extern-c" class="headerlink" title="extern c"></a>extern c</h2><p>C++中extern “C”修饰函数时，指明该函数以C的方式进行编译和链接。具体来说就是C++函数支持函数重载，C不支持函数重载，原因二者的函数签名不同。<br>如函数void foo(int,int)被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为”mangledname”）。</p>
<h1 id="c-11"><a href="#c-11" class="headerlink" title="c++11"></a>c++11</h1><h2 id="map、unordered-map"><a href="#map、unordered-map" class="headerlink" title="map、unordered_map"></a>map、unordered_map</h2><p>map：<br>优点：<br>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高<br>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间<br>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p>unordered_map：<br>优点： 因为内部实现了哈希表，因此其查找速度非常的快<br>缺点： 哈希表的建立比较耗费时间<br>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p>总结：<br>内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。<br>但是unordered_map执行效率要比map高很多<br>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的<br>map和unordered_map的使用<br>unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/WindSun/p/11444429.html">https://www.cnblogs.com/WindSun/p/11444429.html</a></p>
<p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。</p>
<p>为什么使用智能指针</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<p>shared_ptr</p>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr是否线程安全，</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c75a0d33655c">https://www.jianshu.com/p/c75a0d33655c</a></p>
<p>虽然我们借shared_ptr 来实现线程安全的对象释放，但是shared_ptr 本身不是100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为shared_ptr 有两个数据成员，读写操作不能原子化</p>
<p>shared_ptr肯定是线程安全的，但是</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*shared_ptr.get()</span><br></pre></td></tr></table></figure>

<p>就不一定</p>
<p>如何设计一个线程安全的shared_ptr？</p>
<p>使用<strong>weak_ptr.lock</strong>函数就可以得到一个shared_ptr的指针，如果该指针已经被其它地方释放，它则返回一个空的shared_ptr，也可以使用weak_ptr.expired()来<strong>判断一个指针是否被释放</strong>。</p>
<p>weak_ptr</p>
<p>share_ptr虽然已经很好用了，但是有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>
<p>unitue_ptr</p>
<p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22111546/answer/30801982">https://www.zhihu.com/question/22111546/answer/30801982</a></p>
<p>右值引用的意义通常解释为两大作用：移动语义和完美转发</p>
<p>移动语义，简单来说解决的是各种情形下<strong>对象的资源所有权转移</strong>的问题。而在C++11之前，移动语义的缺失是C++饱受诟病的问题之一。</p>
<p>如何将大象从一台冰箱转移到另一台冰箱？<br>普通解答：打开冰箱门，取出大象，关上冰箱门，打开另一台冰箱门，放进大象，关上冰箱门。<br>2B解答：在第二个冰箱中启动量子复制系统，克隆一只完全相同的大象，然后启动高能激光将第一个冰箱内的大象气化消失。<br>等等，这个2B解答听起来很耳熟，这不就是C++中要<strong>移动</strong>一个对象时所做的事情吗？</p>
<p>C++通过拷贝构造函数和拷贝赋值操作符为类设计了<strong>拷贝/复制</strong>的概念，但为了实现对资源的<strong>移动</strong>操作，调用者必须使用先复制、再析构的方式。否则，就需要自己实现移动资源的接口。</p>
<p><strong>右值</strong>（相对应的还有<strong>左值</strong>）是从C语言设计时就有的概念，但因为其如此基础，也是一个最常被忽略的概念。不严格的来说，左值对应变量的存储位置，而右值对应变量的值本身。C++中右值可以被赋值给左值或者绑定到引用。类的右值是一个临时对象，如果没有被绑定到引用，在表达式结束时就会被废弃。于是我们可以在右值被废弃之前，移走它的资源进行废物利用，从而避免无意义的复制。被移走资源的右值在废弃时已经成为空壳，析构的开销也会降低。</p>
<h1 id="PYTHON基础"><a href="#PYTHON基础" class="headerlink" title="PYTHON基础"></a>PYTHON基础</h1><h3 id="python与c的区别"><a href="#python与c的区别" class="headerlink" title="python与c的区别"></a>python与c的区别</h3><p>开发效率<br>运行效率<br>应用场景</p>
<p>C属编译型语言，Python属解释型语言<br>编译型的优点是“静态”，代码不能一行一行编译执行，必须作为整个工程来编译，这样便于类型检查，降低运行时错误率；运行时效率更高，因为编译器可以统筹各个方面，生成更优化的机器指令；一经编译便可直接以机器语言再次执行。<br>解释型语言的优点是“动态”，代码的每一行可独立执行（代码块除外）。这样就可以灵活地进行实时交互，调整正在运行的程序，进行实时、异步的调试。比如 Python 的 CLI（命令行交互界面）就可以直接输入 Python 代码执行。这是 C 语言这样的编译语言难以做到的（调试模式下可以做到 C 表达式的实时计算，但达不到解释型语言的灵活度）。解释型语言的特性还让其适合做脚本语言。</p>
<p>二者的缺点则互为对方占优的方面。编译型需要大量的编译时间，不够灵活。在大项目中，需求的更改可能导致巨大的重新编译时间。不过这被运行效率弥补，没有其他更大的缺点。而解释型语言被诟病得相对较多，比如因为不能事先编译，执行时都要先解释（本质上就是对单行的编译）成机器代码再执行，因此效率低很多。不过针对这点，Python 现在会像编译型语言一样把第一次执行时产生的字节码（虚拟机器代码）输出到 .pyc 文件，下次若源文件未改变，可直接执行字节码文件，从而提升了运行效率。另外，解释型语言难以实现静态类型检查，所以容易产生运行时错误，因此相对不适合用来做大项目。</p>
<h3 id="python-的GIL、多线程、多进程"><a href="#python-的GIL、多线程、多进程" class="headerlink" title="python 的GIL、多线程、多进程"></a>python 的GIL、多线程、多进程</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20953544">https://zhuanlan.zhihu.com/p/20953544</a></p>
<p>GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p>
<p>多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大</p>
<h3 id="深拷贝-deepcopy"><a href="#深拷贝-deepcopy" class="headerlink" title="深拷贝 deepcopy"></a>深拷贝 deepcopy</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/richardzhu/p/4723750.html">https://www.cnblogs.com/richardzhu/p/4723750.html</a>.   </p>
<p>a = copy.deepcopy(b)<br>则b变化，a不会跟着变</p>
<p>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。</p>
<p>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说（ 新瓶装新酒 ）。</p>
<h3 id="python2和python3区别？"><a href="#python2和python3区别？" class="headerlink" title="python2和python3区别？"></a>python2和python3区别？</h3><p>​    1、Python3 使用 print 必须要以小括号包裹打印内容，比如 print(‘hi’)</p>
<p>​    Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比        如 print ‘hi’</p>
<p>​     2、python2 range(1,10)返回列表，python3中返回迭代器，节约内存</p>
<p>​    3、python2中使用ascii编码，python中使用utf-8编码</p>
<p>​    4、python2中unicode表示字符串序列，str表示字节序列</p>
<p>​      python3中str表示字符串序列，byte表示字节序列</p>
<p>​    5、python2中为正常显示中文，引入coding声明，python3中不需要</p>
<p>​    6、python2中是raw_input()函数，python3中是input()函数</p>
<h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h1><h2 id="进程、线程、协程的区别"><a href="#进程、线程、协程的区别" class="headerlink" title="进程、线程、协程的区别"></a>进程、线程、协程的区别</h2><p>进程:<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。<br>线程:<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。<br>协程:<br>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）<br>对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p>
<h2 id="协程的底层实现原理"><a href="#协程的底层实现原理" class="headerlink" title="协程的底层实现原理"></a>协程的底层实现原理</h2><p>协程是基于线程的。内部实现上，维护了一组数据结构和 n 个线程，真正的执行还是线程，协程执行的代码被扔进一个待执行队列中，由这 n 个线程从队列中拉出来执行。这就解决了协程的执行问题。那么协程是怎么切换的呢？答案是：golang 对各种 io函数 进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步 io函数，当这些异步函数返回 busy 或 bloking 时，golang 利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行，基本原理就是这样，利用并封装了操作系统的异步函数。包括 linux 的 epoll、select 和 windows 的 iocp、event 等。</p>
<h2 id="golang中的channel"><a href="#golang中的channel" class="headerlink" title="golang中的channel"></a>golang中的channel</h2><p>Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量<br>Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。</p>
<p>golang中的channel，为什么它可以做到线程安全<br>Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication),Channel也可以理解是一个先进先出的队列，通过管道进行通信。<br>Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据 都是 原子性的。而且Go的设计思想就是:不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的。</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h2><p>​    HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>​    HashMap的数据结构：在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br>​    当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。<br>​    需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p>
<h2 id="深拷贝和浅拷贝区别是什么"><a href="#深拷贝和浅拷贝区别是什么" class="headerlink" title="深拷贝和浅拷贝区别是什么"></a>深拷贝和浅拷贝区别是什么</h2><p>​    浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>​    深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p>
<h2 id="spring-事务实现方式有哪些"><a href="#spring-事务实现方式有哪些" class="headerlink" title="spring 事务实现方式有哪些"></a>spring 事务实现方式有哪些</h2><ol>
<li>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。</li>
<li>基于 TransactionProxyFactoryBean 的声明式事务管理</li>
<li>基于 @Transactional 的声明式事务管理</li>
<li>基于 Aspectj AOP 配置事务</li>
</ol>
<h2 id="spring-的事务隔离"><a href="#spring-的事务隔离" class="headerlink" title="spring 的事务隔离"></a>spring 的事务隔离</h2><p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p>
<ul>
<li>脏读：一个事务读到另一个事务未提交的更新数据。</li>
<li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li>
<li>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</li>
</ul>
<h2 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h2><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>
<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p>
<h2 id="线程的-run-和-start-有什么区别"><a href="#线程的-run-和-start-有什么区别" class="headerlink" title="线程的 run()和 start()有什么区别"></a>线程的 run()和 start()有什么区别</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h1 id="数据结构与算法相关"><a href="#数据结构与算法相关" class="headerlink" title="数据结构与算法相关"></a>数据结构与算法相关</h1><h2 id="数组和链表的优缺点"><a href="#数组和链表的优缺点" class="headerlink" title="数组和链表的优缺点"></a>数组和链表的优缺点</h2><p>数组，在内存上给出了连续的空间。链表，内存地址上可以是不连续的，每个链表的节点包括原来的内存和下一个节点的信息(单向的一个，双向链表的话，会有两个)。<br>数组优于链表的:<br>A. 内存空间占用的少。<br>B. 数组内的数据可随机访问，但链表不具备随机访问性。<br>C. 查找速度快<br>链表优于数组的:<br>A. 插入与删除的操作方便。<br>B. 内存地址的利用率方面链表好。<br>C. 方便内存地址扩展。</p>
<h2 id="给定一个单向链表（长度未知），请设计一个既节省时间又节省空间的算法来找出该链表中的倒数第m个元素。"><a href="#给定一个单向链表（长度未知），请设计一个既节省时间又节省空间的算法来找出该链表中的倒数第m个元素。" class="headerlink" title="给定一个单向链表（长度未知），请设计一个既节省时间又节省空间的算法来找出该链表中的倒数第m个元素。"></a>给定一个单向链表（长度未知），请设计一个既节省时间又节省空间的算法来找出该链表中的倒数第m个元素。</h2><p>实现这个算法，并为可能出现的特例情况安排好处理措施。“倒数第m个元素”是这样规定的：当m=0时，链表的最后一个元素将被返回。<br>解决问题方法思路如下：<br>方法一、如果我们知道链表的长度n，查找倒数第m个元素，也就是查找正序的第（n -  m）个元素（这里的序号只是为了分析，可能跟题目不一定正确的符合）。那么这样来说就简单很多。首先遍历链表得到链表长度，然后重新遍历一次，查找正数第（n-m）个元素。时间复杂度大约是O(2n)。<br>方法二、我们是不是可以提供一个辅助存储空间，是的我们在遍历到链表结束的时候可以回溯到倒数第m个元素。比如用一个支持随机访问的容器记录链表每一个节点的地址。那么这样的就可以只遍历一次链表就能得到结果。时间复杂度大约是O(n)，但是我们是用空间换取时间的，辅助存储空间的大小由m决定，如果m过大也是不可取的。<br>方法三、头结点指针为当前指针，尾节点指针为拖后指针。开始的时候当前指针和拖后指针初始化为链表的头结点，首先我们让当前指针遍历到第m个元素，拖后指针不变；然后同步更新当前指针和拖后指针；直到当前指针为链表结尾。这样我们就能保证当前指针和拖尾指针之间的距离是m。</p>
<h2 id="100w个数，找其中最大的100个（用快排）"><a href="#100w个数，找其中最大的100个（用快排）" class="headerlink" title="100w个数，找其中最大的100个（用快排）"></a>100w个数，找其中最大的100个（用快排）</h2><h2 id="一组数据，找其中两两相加和为M的多组数据（用m减去所有的值放入hash表中）"><a href="#一组数据，找其中两两相加和为M的多组数据（用m减去所有的值放入hash表中）" class="headerlink" title="一组数据，找其中两两相加和为M的多组数据（用m减去所有的值放入hash表中）"></a>一组数据，找其中两两相加和为M的多组数据（用m减去所有的值放入hash表中）</h2><ol>
<li>O(n<em>log(n))的解法：先对数组进行排序（时间复杂度为O(n</em>log(n))），在排序的数组中依次查找target-arr[i]是否在数组中，查找target-arr[i]时可以用二分查找（时间复杂度为O(log(n))），遍历数组一遍知道找到target-arr[i]在数组中为止，所以查找的时间复杂度为O(n<em>log(n))，总的时间复杂度为O(n</em>log(n))。</li>
<li>另一种O(n<em>log(n))的解法：《编程之美》2.12给出的解法三比较有意思，比1有一些改进，主要改进了查找的过程。首先也是要对数组进行排序（时间复杂度为O(n</em>log(n))），然后再已排序的数组中，令i=0，j=n-1，判断arr[i]+arr[j]是否等于target，等于则结束，如果小于target，则i=i+1；如果大于target，则j=j-1，这样查找符合条件的两个元素的过程只需要遍历数组一次，因此查找的时间复杂度降低到O(n)，总的时间复杂度还是O(n*log(n))。</li>
<li>O(n)的解法：将数组中的所有元素存入hash表中，遍历一遍时间复杂度O(n)，然后再遍历一遍数组，查找target-arr[i]是否出现在hash表中，因为在hash表中查找的过程只需O(1)时间，所以第二次遍历的时间复杂度也是O(n)，总的时间复杂度为O(n)。但是该方法也是有弊端的（也是hash表固有的弊端），就是较高的空间复杂度——需要O(n)的hash表存储空间，例如{1，3，6,100000}这样一个数组就需要用100000的空间来存储，存储效率太低太低！另外说明一下，因为这里只需要标记数是否出现过，所以这里用Bitmap数据结构（见：）可以适当的节省空间。hash表是一种用空间换时间的方法，所以该题需要根据实际情况选取合适的方法。</li>
</ol>
<h2 id="给定字符串，转换为整数"><a href="#给定字符串，转换为整数" class="headerlink" title="给定字符串，转换为整数"></a>给定字符串，转换为整数</h2><p>输入一个由数字组成的字符串，把它转换成整数并输出。<br>给定函数原型int StrToInt(const char *str) ，实现字符串转换成整数的功能，不能使用库函数atoi。</p>
<p>需注意的问题<br>1、空指针输入：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。<br>2、正负符号：整数不仅包含数字，还有可能是以’+’或’-‘开头表示正负整数，因此如果第一个字符是’-‘号，则要把得到的整数转换成负整数。<br>3、非法字符：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。<br>4、整型溢出：输入的数字是以字符串的形式输入，因此输入一个很长的字符串将可能导致溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = (<span class="keyword">int</span>)((<span class="keyword">unsigned</span>)~<span class="number">0</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MIN_INT = -(<span class="keyword">int</span>)((<span class="keyword">unsigned</span>)~<span class="number">0</span> &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否输入为空</span></span><br><span class="line">    <span class="keyword">if</span> (str == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理空格</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(*str))</span><br><span class="line">        ++str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理正负</span></span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span> || *str == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定是数字后才执行循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(*str))&#123;</span><br><span class="line">        <span class="comment">//处理溢出</span></span><br><span class="line">        <span class="keyword">int</span> c = *str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (sign &gt; <span class="number">0</span> &amp;&amp; (n &gt; MAX_INT / <span class="number">10</span> || (n == MAX_INT / <span class="number">10</span> &amp;&amp; c &gt; MAX_INT % <span class="number">10</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            n = MAX_INT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sign &lt; <span class="number">0</span> &amp;&amp; (n &gt;(<span class="keyword">unsigned</span>)MIN_INT / <span class="number">10</span> || (n == (<span class="keyword">unsigned</span>)MIN_INT / <span class="number">10</span> &amp;&amp; c &gt; (<span class="keyword">unsigned</span>)MIN_INT % <span class="number">10</span>)))&#123;</span><br><span class="line">            n = MIN_INT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把之前得到的数字乘以10，再加上当前字符表示的数字。</span></span><br><span class="line">        n = n * <span class="number">10</span> + c;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign &gt; <span class="number">0</span> ? n : -n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（没有考虑空格、负数，溢出）</p>
<h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><p>递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        struct ListNode *newhead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>非递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">cur</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> =</span> head-&gt;next-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8460958.html">https://www.cnblogs.com/alantu2018/p/8460958.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8460958.html">https://www.cnblogs.com/alantu2018/p/8460958.html</a></p>
<p>判断二叉树是否是完全二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.push(root);</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasNoChild = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* temp = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (hasNoChild)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;left || temp-&gt;right)&#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left &amp;&amp; temp-&gt;right)&#123;</span><br><span class="line">                    Q.push(temp-&gt;left);</span><br><span class="line">                    Q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp-&gt;left &amp;&amp; !temp-&gt;right)&#123;</span><br><span class="line">                    Q.push(temp-&gt;left);</span><br><span class="line">                    hasNoChild = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!temp-&gt;left &amp;&amp; temp-&gt;right)&#123;</span><br><span class="line">                    result = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    hasNoChild = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>计算完全二叉树节点个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calCompleteTreeNodes</span><span class="params">(TreeNode *troot)</span> </span>&#123;</span><br><span class="line">    TreeNode * left = troot;</span><br><span class="line">    TreeNode * right = troot;</span><br><span class="line">    <span class="keyword">int</span> nleft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nright = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(troot == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left)&#123;</span><br><span class="line">        left = left-&gt;left;</span><br><span class="line">        nleft++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right)&#123;</span><br><span class="line">        right = right-&gt;right;</span><br><span class="line">        nright++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nleft == <span class="number">1</span>)&#123; &lt;--- 这里需要判断吗？</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nleft == nright)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, nleft) - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calCompleteTreeNodes(troot-&gt;left) + calCompleteTreeNodes(troot-&gt;right) + <span class="number">1</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度：logN*logN</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28063811/article/details/93034625">https://blog.csdn.net/qq_28063811/article/details/93034625</a></p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84316213">https://zhuanlan.zhihu.com/p/84316213</a></p>
<h2 id="tcp三次握手的过程"><a href="#tcp三次握手的过程" class="headerlink" title="tcp三次握手的过程"></a>tcp三次握手的过程</h2><p><img src="https://pic2.zhimg.com/v2-1c5da3391ad30aa7aa30f9362407a77f_b.jpg" alt="img"></p>
<p>最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。<br>一开始，B 的 TCP 服务器进程首先创建传输控制块TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。<br>第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。<br>第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。<br>第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p>
<p>accept发生在三次握手哪个阶段？<br>三次握手完成后，客户端和服务器就建立了tcp连接。这时可以调用accept函数获得此连接。client 的 connect  引起3次握手，server 在socket， bind， listen后，阻塞在accept，三次握手完成后，accept返回一个fd，<br>因此accept发生在三次握手之后。</p>
<p>为什么2次握手不行<br>为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。<br>对于上面这种情况，如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。<br>如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。</p>
<p>为什么不需要四次握手<br>有人可能会说A发出第三次握手的信息后在没有接收到B的请求就已经进入了连接状态，那如果A的这个确认包丢失或者滞留了怎么办？<br>我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。</p>
<p>Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN<br>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。<br>SYN 是 TCP / IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
<p>传了 SYN，为什么还要传 ACK？<br>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://pic3.zhimg.com/80/v2-dc0bdc69237df055ff8c2aa477887237_1440w.jpg" alt="img"></p>
<p>第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。<br>第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。<br>第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。<br>第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。</p>
<p>为什么 TIME-WAIT 状态必须等待 2MSL 的时间</p>
<p>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。<br>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
<h2 id="TCP-amp-UDP"><a href="#TCP-amp-UDP" class="headerlink" title="TCP&amp;UDP"></a>TCP&amp;UDP</h2><p>TCP 的主要特点是什么</p>
<ol>
<li>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；</li>
<li>TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ol>
<p>UDP 的主要特点是什么</p>
<ol>
<li>UDP 是无连接的；</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP 是面向报文的；</li>
<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信；</li>
<li>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>
</ol>
<p>TCP 协议是如何保证可靠传输的</p>
<ol>
<li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</li>
<li>对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</li>
<li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li>
<li>应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li>
<li>超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li>
<li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</li>
</ol>
<p>TCP 和 UDP 的区别<br>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。<br>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。</p>
<h2 id="在浏览器中输入-URL-地址到显示主页的过程"><a href="#在浏览器中输入-URL-地址到显示主页的过程" class="headerlink" title="在浏览器中输入 URL 地址到显示主页的过程"></a>在浏览器中输入 URL 地址到显示主页的过程</h2><ol>
<li>DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；</li>
<li>服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li>浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
<li>连接结束。</li>
</ol>
<h2 id="http-amp-https"><a href="#http-amp-https" class="headerlink" title="http &amp; https"></a>http &amp; https</h2><p>HTTP 和 HTTPS 的区别</p>
<ol>
<li>开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</li>
<li>资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；</li>
<li>端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</li>
<li>安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li>
</ol>
<p>HTTPS 的优缺点<br>优点：</p>
<ol>
<li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；</li>
<li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
</ol>
<p>缺点</p>
<ol>
<li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；</li>
<li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li>
<li>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；</li>
<li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；</li>
<li>HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</li>
</ol>
<p>什么是对称加密和非对称加密？<br>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。<br>非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。<br>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<h1 id="工程类相关"><a href="#工程类相关" class="headerlink" title="工程类相关"></a>工程类相关</h1><h2 id="多线程和多进程的区别"><a href="#多线程和多进程的区别" class="headerlink" title="多线程和多进程的区别"></a>多线程和多进程的区别</h2><p>（重点 必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）！</p>
<p>1）进程数据是分开的:共享复杂，需要用IPC，同步简单；多线程共享进程数据：共享简单，同步复杂<br>2）进程创建销毁、切换复杂，速度慢 ；线程创建销毁、切换简单，速度快<br>3）进程占用内存多， CPU利用率低；线程占用内存少， CPU利用率高<br>4）进程编程简单，调试简单；线程 编程复杂，调试复杂<br>5）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉<br>6）进程适应于多核、多机分布；线程适用于多核<br>线程所私有的：<br>线程id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno变量、</p>
<p>进程：资源管理和分配的基本单位，每个进程都有自己的地址空间。进程由程序代码、代码 相关的数据集和进程控制块（PCB）3 部分组成。<br>线程：CPU 调度和分派的基本单位，线程是属于进程的，它运行在进程空间内，同一进程所产生的线程共享同一内存空间。每个线程有独立的栈和线程控制块（TCB，包含寄存器的值、 程序计数器、优先级等）。<br>并发度：两者都可提高并发度<br>开销：线程执行开销小，但不利于资源管理和保护，进程创建和销毁系统都要分配和回 收资源，开销大。<br>速度：线程的产生、通信、切换都比较快；<br>资源利用率：线程的资源利用率好，因为共享数据；<br>同步：线程使用公共变量和内存时需使用同步机制。<br>资源：线程不拥有系统资源，但可以使用进程的资源。<br>适用情况：线程适合在 SMP(多处理器)的机器上运行，进程可跨机器迁移。</p>
<p>线程共享的环境包括：<br>  1.进程代码段<br>  2.进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)<br>  3.进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。<br>线程独立的资源包括：<br>1.线程ID<br>每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。<br>2.寄存器组的值<br>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存<br>器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。<br>3.线程的堆栈<br>堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的<br>函数堆栈， 使得函数调用可以正常执行，不受其他线程的影响。<br>4.错误返回码<br>由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该 线程还没有处理这个错误，<br>另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量。<br>5.线程的信号屏蔽码<br>由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都 共享同样的信号处理器。<br>6.线程的优先级<br>由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。</p>
<h2 id="动态链接和静态链接的区别？"><a href="#动态链接和静态链接的区别？" class="headerlink" title="动态链接和静态链接的区别？"></a>动态链接和静态链接的区别？</h2><p>动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在可执行文件运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了</p>
<h2 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h2><table>
<thead>
<tr>
<th align="left">分类</th>
<th>io模型</th>
<th>具体实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同步io</td>
<td>同步阻塞io</td>
<td>阻塞式的read和write函数调用</td>
</tr>
<tr>
<td align="left">同步io</td>
<td>同步非阻塞io</td>
<td>以O_NONBLOCK参数打开fd，然后执行read和write函数调用</td>
</tr>
<tr>
<td align="left">同步io</td>
<td>io多路复用</td>
<td>linux下三种io多路复用<br />select、poll、epoll      java的NIO</td>
</tr>
<tr>
<td align="left">异步io</td>
<td>异步io</td>
<td>win上的IOCP<br />c++ boost asio库（框架模拟出来的异步IO）<br />linux aio</td>
</tr>
</tbody></table>
<p>阻塞/非阻塞是从函数调用角度来说的，同步和异步是从『读写是谁完成』角度来说的<br>阻塞：如果读写未就绪或读写未完成，则函数一直等待<br>非阻塞：函数立即返回，然后让应用程序轮询<br>同步：读写由应用程序完成<br>异步：读写由操作系统完成，完成后，回调或事件通知应用程序</p>
<p>异步IO一定是非阻塞IO，不存在既是异步IO，又是阻塞的；同步IO可能是阻塞的，也可能是非阻塞的，归类后有三种：同步阻塞IO、同步非阻塞IO、异步IO</p>
<p>IO多路复用（select、poll、epoll）都是同步IO，因为read和write函数操作都是应用程序完成的，同时也是阻塞IO，因为select、read、write的调用都是阻塞的</p>
<p>Reactor模式：<br>主动模式。所谓主动，是指应用程序不断轮询，询问操作系统或者网络框架、IO是否就绪，linux下的select、poll、epoll就属于主动模式，需要应用程序中有一个循环一直轮询，java中的NIO也属于这种模式，在这种模式下，实际IO操作还是应用程序执行</p>
<p>Proactor模式：<br>被动模式。应用程序把read和write函数操作全部交给操作系统或者网络框架，实际的IO操作由操作系统或网络框架完成，之后再回调应用程序，asio库就是典型的proactor模式<br>异步IO是proactor模式</p>
<p>select、epoll的LT与ET<br>epoll过程的三个步骤：<br>1、事件注册，通过函数epoll_ctl实现，对于服务器而言，是accept、read、write三种事件，对于客户端而言，是connect、read、write三种事件<br>2、轮询这三个事件是否就绪，通过epoll_wait实现，有事件发生时，该函数返回<br>3、事件就绪，执行实际的IO操作，通过函数accept、read、write实现</p>
<p>什么是事件就绪<br>1、read事件就绪：远程有数据来了，socket读取缓存区里有数据，需要调用read函数处理<br>2、write事件就绪：本地socket写缓冲区是否可写。如果缓冲区未满，则一直是可写的，write事件一直是就绪的，可以调用write函数<br>3、accept事件就绪：有新的连接进入，需要调用accept函数处理</p>
<p>epoll的LT和ET模式<br>LT（水平触发):读缓冲区只要不为空，就会一直触发读事件；写缓冲区只要不满，就会一直触发写事件<br>ET（边缘触发):读缓冲区的状态，从空转为非空的时候出发一次；写缓冲区的状态，从满转为非满的时候触发一次。</p>
<p>LT和ET需要注意的问题<br>对于LT模式，要避免『写的死循环』问题：写缓冲区为满的概率很小，即『写的条件』会一直满足，所以当用户注册了写事件却没有数据要写时，它会一直触发，所以在LT模式下，写完数据一定要取消写事件。<br>对于ET模式，要避免『short read』问题，如用户收到100个字节，触发一次，担用户只读到50个字节，剩下的50个字节不读，它也不会再次触发，因此ET模式下，一定要把读缓冲区的内容一次性读完<br>在实际开发中，大家更倾向于LT，也是默认的模式，因为ET容易漏事件，LT重复触发有少许性能损耗，但是安全</p>
<h2 id="有用过Linux中的epoll吗？它的作用是什么"><a href="#有用过Linux中的epoll吗？它的作用是什么" class="headerlink" title="有用过Linux中的epoll吗？它的作用是什么"></a>有用过Linux中的epoll吗？它的作用是什么</h2><p>答：<br>epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。<br>问题十二：<br>epoll和select的区别在哪，或者说优势在哪？<br>答：<br>（1）epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered）；<br>（2）select的句柄数目受限，在linux/posix_types.h头文件有这样的声明：#define __FD_SETSIZE 1024，表示select最多同时监听1024个fd。而epoll没有，epoll的最大并发的连接数的理论值无上限，但由于实际内存资源有限，实际并发的连接数受到资源的限制和最大的打开文件句柄数目的限制；<br>（3）epoll的最大好处是不会随着FD的数目增长而降低效率，在selec中采用轮询处理，其中的数据结构类似一个数组的数据结构，而epoll 是维护一个队列，直接看队列是不是空就可以了。<br>（4）使用mmap加速内核与用户空间的消息传递。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。<br>此外，epoll创建时传入的参数是什么？<br>创建一个epoll的实例，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>什么是redis<br>Redis是一种运行速度很快，并发很强的跑在内存上的NoSql数据库，支持键到五种数据类型的映射。</p>
<p>为什么Redis这么快？<br>首先，采用了多路复用io阻塞机制<br>然后，数据结构简单，操作节省时间<br>最后，运行在内存中，自然速度快</p>
<p>Redis为什么是单线程的？<br>因为Redis的瓶颈不是cpu的运行速度，而往往是网络带宽和机器的内存大小。再说了，单线程切换开销小，容易实现既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p>万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？<br>你多起几个Redis进程就好了。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好。</p>
<p>单线程可以处理高并发请求吗？<br>当然可以了，Redis都实现了。有一点概念需要澄清，并发并不是并行。<br>（相关概念：并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元）</p>
<p>简述一下Redis值的五种类型<br>String 整数，浮点数或者字符串<br>Set 集合<br>Zset 有序集合<br>Hash 散列表<br>List 列表</p>
<p>列举几个用得到Redis的常用使用场景?<br>缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；<br>排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定；</p>
<p>计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；</p>
<p>好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；</p>
<p>简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；</p>
<p>Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</p>
<p>一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问</p>
<p>Redis怎样防止异常数据不丢失？<br>RDB 持久化将某个时间点的所有数据都存放到硬盘上。<br>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。<br>如果系统发生故障，将会丢失最后一次创建快照之后的数据。<br>如果数据量很大，保存快照的时间会很长。</p>
<p>AOF 持久化<br>将写命令添加到 AOF 文件（Append Only File）的末尾。<br>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：<br>选项同步频率always每个写命令都同步everysec每秒同步一次no让操作系统来决定何时同步always 选项会严重减低服务器的性能；everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<p>rdb：固定的时间间隔内做快照<br>aof：记录所有redis操作</p>
<p>讲一讲缓存穿透，缓存雪崩以及缓存击穿吧</p>
<p>缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。<br>缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中<br>缓存雪崩：就是大量数据同一时间失效。<br>打个比方，你是个很有钱的人，开满了百度云，腾讯视频各种杂七杂八的会员，但是你就是没有netflix的会员，然后你把这些账号和密码发布到一个你自己做的网站上，然后你有一个朋友每过十秒钟就查询你的网站，发现你的网站没有Netflix的会员后打电话向你要。你就相当于是个数据库，网站就是Redis。这就是缓存穿透。<br>大家都喜欢看腾讯视频上的《水果传》，但是你的会员突然到期了，大家在你的网站上看不到腾讯视频的账号，纷纷打电话向你询问，这就是缓存击穿你的各种会员突然同一时间都失效了，那这就是缓存雪崩了。<br>放心，肯定有办法解决的。<br>缓存穿透：<br>1.接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id&lt;=0的直接拦截；<br>2.缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击<br>缓存击穿：最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员<br>缓存雪崩：<br>1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</p>
<p>Redis中的Master-Slave模式<br>1、主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；<br>2、从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；<br>3、主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p>
<p>分片<br>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。<br>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<p>最简单的方式是范围分片，例如用户 id 从 0<del>1000 的存储到实例 R0 中，用户 id 从 1001</del>2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。<br>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</p>
<p>根据执行分片的位置，可以分为三种分片方式：<br>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。<br>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。<br>服务器分片：Redis Cluster</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904125784653837">https://juejin.im/post/6844904125784653837</a></p>
<p>正向代理&amp;反向代理<br>我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求<br>反向代理隐藏了真实的服务端，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。<br>正向代理代理的对象是客户端，反向代理代理的对象是服务端</p>
<p>什么是Nginx？<br>Nginx是一个轻量级/高性能的反向代理Web服务器，他实现非常高效的反向代理、负载平衡，他可以处理2-3万并发连接数，官方监测能支持5万并发，</p>
<p>为什么要用Nginx？<br>跨平台、配置简单、方向代理、高并发连接：处理2-3万并发连接数，官方监测能支持5万并发，内存消耗小：开启10个nginx才占150M内存，nginx处理静态文件好，耗费内存少，</p>
<p>而且Nginx内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。</p>
<p>使用Nginx的话还能：<br>1、节省宽带：支持GZIP压缩，可以添加浏览器本地缓存<br>2、稳定性高：宕机的概率非常小<br>3、接收用户请求是异步的</p>
<p>为什么Nginx性能这么高？<br>因为他的事件处理机制：异步非阻塞事件处理机制：运用了epoll模型，提供了一个队列，排队解决</p>
<p>Nginx的优缺点？<br>优点：<br>占内存小，可实现高并发连接，处理响应快<br>可实现http服务器、虚拟主机、方向代理、负载均衡<br>Nginx配置简单<br>可以不暴露正式的服务器IP地址<br>缺点：<br>动态处理差：nginx处理静态文件好,耗费内存少，但是处理动态页面则很鸡肋，现在一般前端用nginx作为反向代理抗住压力，</p>
<p>Nginx应用场景？<br>http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。<br>虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。<br>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。<br>nginz 中也可以配置安全管理、比如可以使用Nginx搭建API接口网关,对每个接口服务进行拦截。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>git的三个分区<br>工作区 （add）-&gt; 暂存区 (commit) -&gt;版本库 （push）远程仓库</p>
<p>git 如何处理版本冲突<br>git merge 和 git rebase的区别<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f23f72251abc">https://www.jianshu.com/p/f23f72251abc</a></p>
<p>marge 特点：自动创建一个新的commit<br>如果合并的时候遇到冲突，仅需要修改后重新commit<br>优点：记录了真实的commit情况，包括每个分支的详情<br>缺点：因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。</p>
<p>rebase 特点：会合并之前的commit历史<br>优点：得到更简洁的项目历史，去掉了merge commit<br>缺点：如果合并出现代码问题不容易定位，因为re-write了history</p>
<p>总结：<br>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容<br>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面<br>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面<br>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面<br>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定<br>rebase 操作会丢弃当前分支已提交的 commit，故不要在已经 push 到远程，和其他人正在协作开发的分支上执行 rebase 操作</p>
<p>git pull 和 git fetch 之间有什么区别？<br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903855847636999">https://juejin.im/post/6844903855847636999</a><br>git pull = git fetch + git merge<br>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。<br>git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。<br>当你使用 pull，Git 会试着自动为你完成工作。它是上下文（工作环境）敏感的，所以 Git 会把所有拉取的提交合并到你当前处理的分支中。<br>pull 则是 自动合并提交而没有让你复查的过程。如果你没有细心管理你的分支，你可能会频繁遇到冲突。<br>当你 fetch，Git 会收集目标分支中的所有不存在的提交，并将这些提交存储到本地仓库中。但Git 不会把这些提交合并到当前分支中。这种处理逻辑在当你需要保持仓库更新，在更新文件时又希望处理可能中断的事情时，这将非常实用。而将提交合并到主分支中，则该使用 merge。</p>
<p>不小心把配置文件推送到了远程仓库，如何从 git 中删除文件，而不将其从文件系统中删除？<br>如果你在 git add 过程中误操作，你最终会添加不想提交的文件。但是，git rm 则会把你的文件从你暂存区（索引）和文件系统（工作树）中删除，这可能不是你想要的。<br>换成 git reset 操作：<br>git reset filename  # orecho filename &gt;&gt; .gitingore # add it to .gitignore to avoid re-adding it</p>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82998949">https://zhuanlan.zhihu.com/p/82998949</a></p>
<p>1、Kafka 都有哪些特点？<br>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。<br>可扩展性：kafka集群支持热扩展<br>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失<br>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）<br>高并发：支持数千个客户端同时读写</p>
<p>2、请简述下你在哪些场景下会选择 Kafka？<br>日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、HBase、Solr等。<br>消息系统：解耦和生产者和消费者、缓存消息等。<br>用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。<br>运营指标：Kafka也经常用来记录运营监控数据。<br>包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。<br>流式处理：比如spark streaming和 Flink</p>
<p>3、Kafka 是如何实现高吞吐率的？<br>Kafka是分布式消息系统，需要处理海量的消息，Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。kafka主要使用了以下几个方式实现了超高的吞吐率：<br>顺序读写；<br>零拷贝<br>文件分段<br>批量发送<br>数据压缩</p>
<p>4、Kafka 分区的目的？<br>分区对于 Kafka 集群的好处是：实现负载均衡。分区对于消费者来说，可以提高并发度，提高效率。</p>
<p>5、你知道 Kafka 是如何做到消息的有序性？<br>kafka 中的每个 partition 中的消息在写入时都是有序的，而且单独一个 partition 只能由一个消费者去消费，可以在里面保证消息的顺序性。但是分区之间的消息是不保证有序的。</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59838091">https://zhuanlan.zhihu.com/p/59838091</a></p>
<p>1、优化数据库的方法<br>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM<br>使用连接(JOIN)来代替子查询<br>适用联合(UNION)来代替手动创建的临时表<br>事务处理<br>锁定表、优化事务处理<br>适用外键，优化锁定表<br>建立索引<br>优化查询语句</p>
<p>2、简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）<br>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。<br>普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。<br>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。<br>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。<br>索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</p>
<p>3、事务特性：<br>（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。<br>（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态<br>（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，<br>（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</p>
<p>4、SQL注入漏洞产生的原因？如何防止？<br>SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。<br>防止SQL注入的方式：开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置<br>执行sql语句时使用addslashes进行sql语句转换<br>Sql语句书写尽量不要省略双引号和单引号。<br>过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。<br>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</p>
<p>4、索引<br>索引的目的是什么？<br>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p>
<p>索引对数据库系统的负面影响是什么？<br>负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p>
<p>为数据表建立索引的原则有哪些？<br>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引</p>
<p>什么情况下不宜建立索引？<br>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等</p>
<h2 id="c-进程内存空间分布"><a href="#c-进程内存空间分布" class="headerlink" title="c++进程内存空间分布"></a>c++进程内存空间分布</h2><p>一个由C/C++编译的程序占用的内存分为以下几个部分：<br>　　1、栈区(stack)：又编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。<br>　　2、堆区(heap)：一般是由程序员分配释放，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。<br>　　3、全局区(static)：也叫静态数据内存空间，存储全局变量和静态变量，全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。<br>　　4、文字常量区：常量字符串就是放在这里，程序结束后由系统释放。<br>　　5、程序代码区：存放函数体的二进制代码。<br>1.从低地址到高地址分别为：代码段、(初始化)数据段、(未初始化)数据段(BSS)、堆、栈、命令行参数和环境变量<br>　　2.堆向高内存地址生长<br>　　3.栈向低内存地址生长</p>
<h2 id="什么是死锁-如何避免死锁"><a href="#什么是死锁-如何避免死锁" class="headerlink" title="什么是死锁?如何避免死锁"></a>什么是死锁?如何避免死锁</h2><p>产生死锁的四个必要条件：<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>（1）互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源<br>（2）请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放<br>（3）不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放<br>（4）环路等待条件：是指进程发生死锁后，必然存在一个进程–资源之间的环形链<br>处理死锁的基本方法：<br>1）.预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件<br>2）.避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁<br>3）.检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉<br>4）.解除死锁：该方法与检测死锁配合使用</p>
<h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><p><a target="_blank" rel="noopener" href="https://www.hi-linux.com/posts/20287.html">https://www.hi-linux.com/posts/20287.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33967414">https://zhuanlan.zhihu.com/p/33967414</a></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/24/hello-world/" rel="next" title="Hello World">
                  Hello World <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
